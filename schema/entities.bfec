
# TODO: ID type declarations
# id EntityID = u32;

struct Entity(type: EntityType) {
  # TODO: Declared IDs
  # entity_id: EntityID;
	entity_type: EntityType = type;
	...EntityContents(@.entity_type);
}

enum EntityType: u8 {
	namespace = 1;
}

switch EntityContents<EntityType> {
	case namespace: NamespaceEntityContents;
	default: invalid;
}

struct NamespaceEntityContents {
	flags: u24 -> bin {
		# ...
	};
  # TODO: References to declared IDs
  # parent: ref<EntityID>;
	# ...
}

# From PNG schema:

# TODO: Checksum-like meta-type for signatures?
#     sig: signature<u8[u32]>(@.data, 'sig_function');

# TODO: Meta-type for compressed data?
#     image_data: compress<ImageData>('gzip');

# ...or a more generic name?
#     image_data: transform<ImageData>('compress:gzip');





# TODO: Map enum to other value literal?
# map bool_str<bool, ascii> {
#   case false: "false";
#   case true:  "true";
# }





# TODO: Look-up / look-behind value expr paths?
#     data: ChunkData(%.Chunk.type);
# ^ read: "find nearest ancestor of type `Chunk`, and take the `type` field from it"

